{"meta":{"title":"dcs的博客","subtitle":"尽量不瞎写","description":"尽量不瞎写","author":"lihao","url":"http://lh2907883.github.io/blog"},"pages":[],"posts":[{"title":"web离线应用","slug":"web离线应用","date":"2017-05-14T07:57:53.000Z","updated":"2017-05-14T09:02:29.000Z","comments":true,"path":"2017/05/14/web离线应用/","link":"","permalink":"http://lh2907883.github.io/blog/2017/05/14/web离线应用/","excerpt":"","text":"什么是web离线应用在正常情况下,客户端使用HTTP协议通过网络得到服务器的资源,然后展示,但是如果在网络断开的情况下,客户端就没办法了,这时就需要一种技术去解决这一问题,目前有两种方式:AppCache和Service Workers,他们都是通过在断网时读取本地缓存资源来实现web应用的离线访问的. 比较AppCache和Service Workers使用方式AppCache通过指定缓存清单文件来设置哪些资源需要被缓存 Service Workers则有更新强大的API来通过脚本精准控制缓存(包括更新,追加,删除缓存) 兼容性下图是各大浏览器对AppCache的支持情况,可以看出基本都支持 而Service Workers还是有一部分浏览器不支持的(特别是移动平台) W3C标准如果你看过AppCache的文档,你会发现 该特性已经从Web标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。 在此刻使用这里描述的应用程序缓存功能高度不鼓励; 它正在处于从Web平台中被删除的过程。请改用Service Workers代替。 我个人认为Service Workers各方面都要优于AppCache,除了兼容性,不过既然Service Workers已经是W3C标准,想必未来的支持情况应该会好一些,所以下面我们将详细讨论Service Workers的用法 使用Service Workers的前提条件 在已经支持 serivce workers 的浏览器的版本中, 很多特性没有默认开启, 需要开启一下浏览器的相关配置： Firefox Nightly: 访问 about:config 并设置 dom.serviceWorkers.enabled 的值为 true; 重启浏览器； Chrome Canary: 访问 chrome://flags 并开启 experimental-web-platform-features; 重启浏览器 (注意：有些特性在Chrome中没有默认开放支持)； Opera: 访问 opera://flags 并开启 ServiceWorker 的支持; 重启浏览器。 另外，你需要通过 HTTPS 来访问你的页面 — 出于安全原因，Service Workers 要求要在必须在 HTTPS 下才能运行。Github 是个用来测试的好地方，因为它就支持HTTPS。为了便于本地开发，localhost 也被浏览器认为是安全源。 如何使用注册service worker12345678910/** * @scriptURL ServiceWorker脚本资源路径(可以是绝对或者相对当前URL的路径) * @options &#123;scope: './'&#125; scope是一个路径,默认值就是'./',它总是相对于ServiceWorker脚本资源路径的,scope指定了一个ServiceWorker的生效范围,只有在这个路径范围内的资源才能支持离线访问(所以跨域的资源是没法离线访问的) */ServiceWorkerContainer.register(scriptURL, options) .then( function(ServiceWorkerRegistration) &#123; // do something &#125;); 代码如下:123456789101112131415//兼容性判断if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('sw.js', &#123;scope: './'&#125;).then(function(reg) &#123; if (reg.installing) &#123; console.log('Service worker installing'); &#125; else if (reg.waiting) &#123; console.log('Service worker installed'); &#125; else if (reg.active) &#123; console.log('Service worker active'); &#125; &#125;).catch(function(error) &#123; // registration failed console.log('Registration failed with ' + error); &#125;);&#125; 事实上当浏览器运行上面的代码时, 会先检测是否之前就获取并注册过sw.js 如果是首次运行,那就先下载并保存在本地, chrome中可以在Application -&gt; Service Workers面板中查看这时会触发Service Worker的install事件,之后会进入navigator.serviceWorker.register返回的Promise.then,状态state为installing. 如果发现本地已经有sw.js (即使本地的sw.js不是最新代码,这次访问任然会使用本地sw.js的代码),那么会直接进入navigator.serviceWorker.register返回的Promise.then,状态state为activated,这时Service Worker为已激活状态,后面只要是有scope范围内的请求都会被Service Worker的fetch事件拦截(注意:如果在scope下的html页面访问了跨域的资源,比如图片什么的,那这个跨域资源请求也会被拦截),在fetch的回调函数里面你可以自行控制是读缓存,还是请求网络,你甚至可以伪造响应数据 (我想这也是为什么Service Worker只支持HTTPS的原因) 如果发现本地已经有sw.js并且本地的sw.js不是最新代码,那么sw.js会自动更新,并触发Service Worker的install事件,在下次访问页面时将使用新版本的sw.js. 关于sw.jssw.js的职责从上面的描述,我们可以看出sw.js的职责其实是控制web应用中资源的访问策略,他和具体的业务逻辑,UI操作都没有任何关系,官方说明: 如果注册成功，service worker 就在 ServiceWorkerGlobalScope 环境中运行； 这是一个特殊类型的 woker 上下文运行环境，与主运行线程（执行脚本）相独立，同时也没有访问 DOM 的能力。 具体实现 注册install事件123456789101112131415this.addEventListener('install', function(event) &#123; //console.log('sw.js install'); event.waitUntil( caches.open('v1').then(function(cache) &#123; return cache.addAll([ '/demo/service-workers/', '/demo/service-workers/index.html', '/demo/service-workers/js/main.js', '/demo/service-workers/json/data.json', '/demo/service-workers/images/1.jpg', '/demo/service-workers/images/2.jpg', ]); &#125;) );&#125;); install 事件一般是被用来填充你的浏览器的离线缓存能力。为了达成这个目的，我们使用了 Service Worker 的 新的标志性的存储 API — cache — 一个 service worker 上的全局对象，它使我们可以存储网络响应发来的资源，并且根据它们的请求来生成key。这个 API 和浏览器的标准的缓存工作原理很相似，但是是特定你的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。注意: Cache API 并不被每个浏览器支持。（查看 Browser support 部分了解更多信息。） 如果你现在就想使用它，可以考虑采用一个 polyfill，比如 Google topeka demo，或者把你的资源存储在 IndexedDB 中。 缓存方案有很多种, 示例代码中采用Cache, 值得注意的是cache.addAll可不仅仅只是记录需要缓存的资源URL列表, 它同时还会fetch这些资源把响应数据缓存起来,以便后面访问的时候使用 (如果是一个复杂的web应用,个人觉得有些不太合理,谁又会在页面刚刚进来时就加载所有资源呢?) 注册fetch事件1234567891011121314151617this.addEventListener('fetch', function(event) &#123; //console.log(event.request); //console.log(caches); event.respondWith( caches.match(event.request) .catch(function() &#123; return fetch(event.request); &#125;).then(function(response) &#123; //console.log(response); caches.open('v1').then(function(cache) &#123; //console.log(cache); cache.put(event.request, response); &#125;); return response.clone(); &#125;) );&#125;); event.respondWith接受一个返回response响应的Promise caches.match会尝试在缓存中匹配当前fetch的请求,匹配到了就直接返回response cache.put则是更新缓存 注册activate事件12345678910111213this.addEventListener('activate', function(event) &#123; var cacheWhitelist = ['v2']; event.waitUntil( caches.keys().then(function(keyList) &#123; return Promise.all(keyList.map(function(key) &#123; if (cacheWhitelist.indexOf(key) === -1) &#123; return caches.delete(key); &#125; &#125;)); &#125;) );&#125;); activate事件回调一般被用来删除旧的缓存 改进后的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344this.addEventListener('install', function(event) &#123; console.log('sw.js install'); event.waitUntil( //这里先不往缓存中写 caches.open('v1').then(function(cache) &#123; return cache.addAll([ // '/demo/service-workers/', // '/demo/service-workers/index.html', // '/demo/service-workers/js/main.js', // '/demo/service-workers/json/data.json', // '/demo/service-workers/images/1.jpg', // '/demo/service-workers/images/2.jpg', // '/demo/service-workers/child.html', ]); &#125;) );&#125;);this.addEventListener('fetch', function(event) &#123; event.respondWith( caches.match(event.request) .then(function(response) &#123; if (response) &#123; //如果匹配到了 return response; &#125; else &#123; //如果有资源没有匹配(比如child.html里面的跨域图片),就先发请求访问,然后缓存一份 console.log('url not match;' + event.request.url); return fetch(event.request).then(function(response) &#123; console.log(response); caches.open('v1').then(function(cache) &#123; cache.put(event.request, response); &#125;); return response.clone(); &#125;); &#125; &#125;) .catch(function() &#123; return fetch(event.request); &#125;) );&#125;);this.addEventListener('activate', function(event) &#123; console.log('activate')&#125;); 演示地址 参考资料 MDN 使用 Service Workers","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://lh2907883.github.io/blog/tags/javascript/"}]},{"title":"关于XMLHttpRequest","slug":"关于XMLHttpRequest","date":"2017-05-07T04:37:45.000Z","updated":"2017-05-07T15:34:46.000Z","comments":true,"path":"2017/05/07/关于XMLHttpRequest/","link":"","permalink":"http://lh2907883.github.io/blog/2017/05/07/关于XMLHttpRequest/","excerpt":"","text":"XMLHttpRequest是什么XMLHttpRequest 是一个API, 它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 兼容性 IE8/IE9也完全不支持xhr对象, 不过可以使用ActiveXObject类生成xhr实例 1new window.ActiveXObject( \"Microsoft.XMLHTTP\" ) IE10/IE11部分支持，不支持 xhr.responseType为json 如何使用使用xhr给后台server发送请求,大概可以分下面几个步骤 1.实例化XMLHttpRequest对象1var xhr = new XMLHttpRequest(); 2.初始化一个请求1xhr.open('POST', '/server', true); open(method, url [, async = true [, username = null [, password = null]]]) async: 默认值为true，即为异步请求，若async=false，则为同步请求 3.设置xhr参数3.1 设置request header 通过调用setRequestHeader方法,设置请求头,这一步必须在xhr.open之后调用 setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式123xhr.setRequestHeader('X-Test', 'one');xhr.setRequestHeader('X-Test', 'two');// 最终request header中\"X-Test\"为: one, two 3.2 设置response type 可以设置xhr.responseType,下面是responseType支持的类型 值 xhr.response 数据类型 说明 “” String 默认值(在不设置responseType时) “text” String “document” Document 对象 希望返回 XML 格式数据时使用 “json” javascript 对象 存在兼容性问题，IE10/IE11不支持 “blob” Blob对象 “arrayBuffer” ArrayBuffer对象 客户端代码12345678910var xhr = new XMLHttpRequest();xhr.open('GET', '/json');xhr.responseType = 'json';xhr.onreadystatechange = function(e) &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //通过xhr.response可以拿到返回的json数据 console.log(this.response); &#125;&#125;;xhr.send(); 服务端代码12345if (req.url == '/json') &#123; res.writeHead(200, &#123; 'content-type': 'application/json' &#125;); res.write('&#123;\"a\": 123, \"b\": \"dcs\"&#125;'); res.end();&#125; 通过调用xhr.overrideMimeType方法来重写response的content-type(不过这个方法我调用之后并没有起作用..) 3.3 设置请求超时可以设置xhr.timeout,来设置超时时间(单位毫秒),在xhr.send()方法调用后开始计时 3.4 设置xhr状态变化时的回调1234567891011121314xhr.onreadystatechange = function () &#123; switch(xhr.readyState)&#123; case 0://UNSENT,open()方法没有调用 break; case 1://OPENED,open()方法已被成功调用,send()方法还未被调用。 break; case 2://HEADERS_RECEIVED,send()方法已经被调用, 响应头和响应状态已经返回 break; case 3://LOADING,响应体下载中,responseText中已经获取了部分数据. break; case 4://DONE,整个请求过程已经完毕. break; &#125;&#125; 3.5 xhr的事件 事件 触发条件 onreadystatechange 每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。 onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。 onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发 onload 当请求成功完成时触发，此时xhr.readystate=4 onloadend 当请求结束（包括请求成功和请求失败）时触发 onabort 当调用xhr.abort()后触发 ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。 onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。 4.发送数据1xhr.send(data); 对于GET/HEAD请求send方法通常不传参数 对于POST/DELETE/PUT请求,xhr.send(data)的参数data可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData 来一个🌰 客户端代码123456789101112131415161718192021222324252627var fileInputElement = document.getElementById('file')var oMyForm = new FormData();oMyForm.append(\"username\", \"dcs\");oMyForm.append(\"num\", 123456); // 数字123456被立即转换成字符串\"123456\"// fileInputElement中已经包含了用户所选择的文件for (var i = 0; i &lt; fileInputElement.files.length; i++) &#123; oMyForm.append(\"file\", fileInputElement.files[i]);&#125;var oFileBody = '&lt;a id=\"a\"&gt;&lt;b id=\"b\"&gt;hey!&lt;/b&gt;&lt;/a&gt;'; // Blob对象包含的文件内容var oBlob = new Blob([oFileBody], &#123; type: \"text/xml\"&#125;);oMyForm.append(\"blob\", oBlob);var xhr = new XMLHttpRequest();xhr.upload.onprogress = function(event) &#123; if (event.lengthComputable) &#123; var completedPercent = event.loaded / event.total; console.log(completedPercent); &#125;&#125;xhr.open(\"POST\", \"/upload\");xhr.send(oMyForm); 服务端代码12345678if (req.url == '/upload' &amp;&amp; req.method.toLowerCase() == 'post') &#123; req.on('data', function(buffer) &#123; //会不时的触发data事件来接受客户端传递的数据 &#125;) .on('end', function() &#123; //数据传递完毕 &#125;);&#125; 注意: 客户端的xhr.upload.onprogress表示的是上传进度触发的回调(进度取决于客户端的网络状况),参数event.total针对的是所有file的总大小, 而服务端的req.on(&#39;data&#39;, function(){})只是这次请求的数据流接受一定量的数据后触发的回调,两者之间没有直接关系 参考资料 你真的会使用XMLHttpRequest吗？ MDN XMLHttpRequest XMLHttpRequest2 新技巧","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://lh2907883.github.io/blog/tags/javascript/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-06T08:43:45.000Z","updated":"2017-05-13T08:19:31.000Z","comments":true,"path":"2017/05/06/hello-world/","link":"","permalink":"http://lh2907883.github.io/blog/2017/05/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}