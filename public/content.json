{"meta":{"title":"dcs的博客","subtitle":"尽量不瞎写","description":"尽量不瞎写","author":"lihao","url":"http://lh2907883.github.io/blog"},"pages":[],"posts":[{"title":"关于XMLHttpRequest","slug":"关于XMLHttpRequest","date":"2017-05-07T04:37:45.000Z","updated":"2017-05-07T15:34:46.000Z","comments":true,"path":"2017/05/07/关于XMLHttpRequest/","link":"","permalink":"http://lh2907883.github.io/blog/2017/05/07/关于XMLHttpRequest/","excerpt":"","text":"XMLHttpRequest是什么XMLHttpRequest 是一个API, 它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 兼容性 IE8/IE9也完全不支持xhr对象, 不过可以使用ActiveXObject类生成xhr实例 1new window.ActiveXObject( \"Microsoft.XMLHTTP\" ) IE10/IE11部分支持，不支持 xhr.responseType为json 如何使用使用xhr给后台server发送请求,大概可以分下面几个步骤 1.实例化XMLHttpRequest对象1var xhr = new XMLHttpRequest(); 2.初始化一个请求1xhr.open('POST', '/server', true); open(method, url [, async = true [, username = null [, password = null]]]) async: 默认值为true，即为异步请求，若async=false，则为同步请求 3.设置xhr参数3.1 设置request header 通过调用setRequestHeader方法,设置请求头,这一步必须在xhr.open之后调用 setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式123xhr.setRequestHeader('X-Test', 'one');xhr.setRequestHeader('X-Test', 'two');// 最终request header中\"X-Test\"为: one, two 3.2 设置response type 可以设置xhr.responseType,下面是responseType支持的类型 值 xhr.response 数据类型 说明 “” String 默认值(在不设置responseType时) “text” String “document” Document 对象 希望返回 XML 格式数据时使用 “json” javascript 对象 存在兼容性问题，IE10/IE11不支持 “blob” Blob对象 “arrayBuffer” ArrayBuffer对象 客户端代码12345678910var xhr = new XMLHttpRequest();xhr.open('GET', '/json');xhr.responseType = 'json';xhr.onreadystatechange = function(e) &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; //通过xhr.response可以拿到返回的json数据 console.log(this.response); &#125;&#125;;xhr.send(); 服务端代码12345if (req.url == '/json') &#123; res.writeHead(200, &#123; 'content-type': 'application/json' &#125;); res.write('&#123;\"a\": 123, \"b\": \"dcs\"&#125;'); res.end();&#125; 通过调用xhr.overrideMimeType方法来重写response的content-type(不过这个方法我调用之后并没有起作用..) 3.3 设置请求超时可以设置xhr.timeout,来设置超时时间(单位毫秒),在xhr.send()方法调用后开始计时 3.4 设置xhr状态变化时的回调1234567891011121314xhr.onreadystatechange = function () &#123; switch(xhr.readyState)&#123; case 0://UNSENT,open()方法没有调用 break; case 1://OPENED,open()方法已被成功调用,send()方法还未被调用。 break; case 2://HEADERS_RECEIVED,send()方法已经被调用, 响应头和响应状态已经返回 break; case 3://LOADING,响应体下载中,responseText中已经获取了部分数据. break; case 4://DONE,整个请求过程已经完毕. break; &#125;&#125; 3.5 xhr的事件 事件 触发条件 onreadystatechange 每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。 onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。 onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发 onload 当请求成功完成时触发，此时xhr.readystate=4 onloadend 当请求结束（包括请求成功和请求失败）时触发 onabort 当调用xhr.abort()后触发 ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。 onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。 4.发送数据1xhr.send(data); 对于GET/HEAD请求send方法通常不传参数 对于POST/DELETE/PUT请求,xhr.send(data)的参数data可以是以下几种类型： ArrayBuffer Blob Document DOMString FormData 来一个🌰 客户端代码123456789101112131415161718192021222324252627var fileInputElement = document.getElementById('file')var oMyForm = new FormData();oMyForm.append(\"username\", \"dcs\");oMyForm.append(\"num\", 123456); // 数字123456被立即转换成字符串\"123456\"// fileInputElement中已经包含了用户所选择的文件for (var i = 0; i &lt; fileInputElement.files.length; i++) &#123; oMyForm.append(\"file\", fileInputElement.files[i]);&#125;var oFileBody = '&lt;a id=\"a\"&gt;&lt;b id=\"b\"&gt;hey!&lt;/b&gt;&lt;/a&gt;'; // Blob对象包含的文件内容var oBlob = new Blob([oFileBody], &#123; type: \"text/xml\"&#125;);oMyForm.append(\"blob\", oBlob);var xhr = new XMLHttpRequest();xhr.upload.onprogress = function(event) &#123; if (event.lengthComputable) &#123; var completedPercent = event.loaded / event.total; console.log(completedPercent); &#125;&#125;xhr.open(\"POST\", \"/upload\");xhr.send(oMyForm); 服务端代码12345678if (req.url == '/upload' &amp;&amp; req.method.toLowerCase() == 'post') &#123; req.on('data', function(buffer) &#123; //会不时的触发data事件来接受客户端传递的数据 &#125;) .on('end', function() &#123; //数据传递完毕 &#125;);&#125; 注意: 客户端的xhr.upload.onprogress表示的是上传进度触发的回调(进度取决于客户端的网络状况),参数event.total针对的是所有file的总大小, 而服务端的req.on(&#39;data&#39;, function(){})只是这次请求的数据流接受一定量的数据后触发的回调,两者之间没有直接关系 参考资料 你真的会使用XMLHttpRequest吗？ MDN XMLHttpRequest XMLHttpRequest2 新技巧","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://lh2907883.github.io/blog/tags/javascript/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-05-06T08:43:45.000Z","updated":"2017-05-13T08:19:31.000Z","comments":true,"path":"2017/05/06/hello-world/","link":"","permalink":"http://lh2907883.github.io/blog/2017/05/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}